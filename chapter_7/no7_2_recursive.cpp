//
//  no7_2_recursive.cpp
//  chapter_7
//
//  Created by Kelang-Tian on 2019/1/29.
//  Copyright © 2019 Kelang-Tian. All rights reserved.
//
/*大家常常感慨，要做好一件事情真的不容易，确实，失败比成功容易多了! 做好“一件”事情尚
 且不易，若想永远成功而总从不失败，那更是难上加难了，就 像花钱总是比挣钱容易的道理一
 样。话虽这样说，我还是要告诉大家，要想失败 到一定程度也是不容易的。比如，我高中的时
 候，就有一个神奇的女生，在英语 考试的时候，竟然把 40 个单项选择题全部做错了!大家都学
 过概率论，应该知 道出现这种情况的概率，所以至今我都觉得这是一件神奇的事情。如果套用一
 句 经典的评语，我们可以这样总结:一个人做错一道选择题并不难，难的是全部做 错，一个不
 对。不幸的是，这种小概率事件又发生了，而且就在我们身边: 事情是这样的——HDU 有个网名叫
 做 8006 的男性同学，结交网友无数，最近该 同学玩起了浪漫，同时给 n 个网友每人写了一
 封信，这都没什么，要命的是，他 竟然把所有的信都装错了信封!注意了，是全部装错哟!现在的
 问题是:请大家 帮可怜的 8006 同学计算一下，一共有多少种可能的错误方式呢?

 输入:
 输入数据包含多个多个测试实例，每个测试实例占用一行，每行包含一个正 整数 n(1<n<=20)，n 表示 8006 的网友的人
 数。

 input:
 2
 3
 output:
 1
 2
 
 在该例中我们也容易得到规模较小时的错装方式数量。如 n 为 1 时， 数量为 0;n 为 2 时数量为 1。我们按照 n 的取值
 顺序将所有的错装方式数量排 列为一个数列，同样用 F[n]表示数列里第 n 个数的取值，F[n]同时代表 n 个信封 的错装方
 式总数，我们确定该数列的递推关系。当 n 大于 3 时，我们考虑 n 封信 全部装错的情况。将信封按顺序由 1 到 n 编
 号。在任意一种错装方案中，假设 n 号信封里装的是 k 号信封的信，而 n 号信封里的信则装在 m 号信封里。我们按
输入数据包含多个多个测试实例，每个测试实例占用一行，每行包含一个正 整数 n(1<n<=20)，n 表示 8006 的网友的人数。
 2 3
 1 2
 照 k 和 m 的等值与否将总的错装方式分为两类。
 若 k 不等于 m，交换 n 号信封和 m 号信封的信后，n 号信封里装的恰好是对
 应的信，而 m 号信封中错装 k 号信封里的信，即除 n 号信封外其余 n-1 个信封 全部错装，其错装方式等于 F[n -
 1]，又由于 m 的 n-1 个可能取值，这类错装方 式总数为(n - 1)* F[n - 1]。也可以理解为，在 n-1 个信封错装的
 F[n - 1]种方式 的基础上，将 n 号信封所装的信与 n - 1 个信封中任意一个信封(共有 n-1 中选 择)所装的信做交换
 后，得到所有信封全部错装的方式数。
 另一种情况，若 k 等于 m，交换 n 号信封和 m 号信封的信后，n 号信封和 m 号信封里装的恰好是对应的信，这样除它们
 之外剩余的 n-2 个信封全部错装，其 错装方式为 F[n - 2]，又由于 m 的 n-1 个取值，这类错装方式总数为(n - 1)*
 F[n - 2]。也可以理解为，在 n - 2 个信封全部错装的基础上，交换最后两个信封中的 信(n 号信封和 1 到 n-1 号信封
 中任意一个，共有 n-1 种选择)，使所有的信封全部 错装的方式数。
 综上所述，F[n] = (n - 1) * F[n - 1] + (n - 1) * F[n - 2]。这就是有名的错排公式。
 */

/*
#include <stdio.h>
long long f[20];
int main(){
    f[1]=0;
    f[2]=1;
    for (int i=3; i<=20; i++) {             //注意，从3开始更新
        f[i] = (i-1)*f[i-1] +(i-2)*f[i-2];
    }
    int n;
    while (scanf("%d",&n)!=EOF) {
        printf("%lld\n",f[n]);
    }
    return 0;
}
*/
